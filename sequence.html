<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>YouthBeat</title>
  <meta name="description" content="YouthBeat">
  <meta name="author" content="The Royal Conservatory">

  <!-- <link rel="stylesheet" href="css/styles.css?v=1.0"> -->

  <script src="https://unpkg.com/konva@3.3.3/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/13.0.1/Tone.min.js"></script>
  <script src="pSBC.js"></script>
  <script src="fill.js"></script>

  <style>
  body {
    background-color: #F5F1F0;
  }
  #content {
    background-color: white;
    width: 1028px;
    margin: auto;
    position: relative;
    }
  .center {
    margin: auto;
    width: 1028px;
  }
  audio {
    width: 100px;
  }
  #controlA {
    position: absolute;
    left: 10px;
    bottom: 10px;
  }
  #controlB {
    position: absolute;
    width: 175px;
    right: 10px;
    bottom: 10px;
    overflow: hidden;
  }
  #mirrorControl {
    position: absolute;
    left: 150px;
    top: 10px;
  }
  #rhythmButtons {
    position: absolute;
    left: 10px;
    top: 0px;
  }
  button {
    margin-top: 10px;
    height: 30px;
    width: 100px;
    display: block;
    border: none;
    font-weight: bold;
    text-transform: uppercase;
    color: white;
    background-color: #B5B5B5;
  }
  #rotateGroup button {
    width: 136px;
  }
  button.rhythm, button.note {
    width: 100px;
  }
  li button {
    width: 20px;
    height: 20px;
    margin: 2px;
    display: inline-block;
  }
  .active {
    font-weight: bold;
    color: #DB3352;
  }
  #tempoLabel {
    display: block;
    margin-top: 20px
  }
  #notes {
    position: absolute;
    right: 10px;
    top: 0px;
  }
  #muteGroup, #rotateGroup {
    margin-top: 20px;
  }
  #presets {
    margin-top: 20px;
    height: 180px;
    overflow: hidden;
    float: right;
  }
  #sequence {
    height: 100px;
    float: right;
  }
  #sequenceDisplay {
    height: 20px;
    width: 100px;
    overflow: hidden;
  }
  #sequenceDisplay span {
    display: inline-block;
    width: 10px;
  }
  ul {
    padding: 0;
    list-style: outside none none;
  }
</style>
</head>

<body>
  <div id="content">
    <div id="container" class="center"></div>
    <div id="controlA">
      <div>
          <input type="checkbox" id="rhythmPolygon" name="rhythmPolygon">
          <label for="rhythmPolygon">Rhythm Polygon</label>
      </div>
      <div id="muteGroup">
        <div>
          <input type="checkbox" id="bassSnareCheck" name="bassSnareCheck" checked>
          <label for="bassSnareCheck">Bass / Snare</label>
        </div>
        <div>
          <input type="checkbox" id="hiHatCheck" name="hiHatCheck" checked>
          <label for="hiHatCheck">Hi-hat</label>
        </div>
        <div>
          <input type="checkbox" id="melodyCheck" name="melodyCheck" checked>
          <label for="melodyCheck">Melody</label>
        </div>
      </div>
      <div id="rotateGroup">
        <button id="bass90">
          Bass / Snare +90
        </button>
        <button id="hihat90">
          Hi-hat +90
        </button>
        <button id="melody90">
          Melody +90
        </button>
      </div>
      <label for="tempo" id="tempoLabel">Tempo: </label><br>
      <input type="range" name="tempo" id="tempo" min="20" max="180" value="90" class="slider">
    </div>
    <div id="mirrorControl">
      <div>
        <input type="checkbox" id="mirrorVertical" name="mirrorVertical">
        <label for="mirrorVertical">Mirror Vertical</label>
      </div>
      <div>
        <input type="checkbox" id="mirrorHorizontal" name="mirrorHorizontal">
        <label for="mirrorHorizontal">Mirror Horizontal</label>
      </div>
      <div>
        <button id="reset">RESET</button>
      </div>
    </div>
    <div id="controlB">
      <div id="presets">
        <button id="savePresetButton">
          Save Preset
        </button>
        <ul id="presetList">
      
        </ul>
      </div>
      <div id="sequence">
        <button id="sequenceControl">
          Start
        </button>
        <div id="sequenceDisplay">
        </div>
        <button id="sequenceClear">
          Clear
        </button>
      </div>
    </div>
    <div id="rhythmButtons">
      <button id="bassDrum" class="rhythm" data-instrument="B">
        Bass Drum
      </button>
      <button id="snareDrum" class="rhythm" data-instrument="S">
        Snare Drum
      </button>
      <button id="rimshot" class="rhythm" data-instrument="R">
        Rim Shot
      </button>
      <button id="hihat" class="rhythm" data-instrument="H">
        Hi-hat
      </button>
      <button id="openHihat" class="rhythm" data-instrument="O">
        Open Hi-hat
      </button>
      <button id="rideCymbal" class="rhythm" data-instrument="C">
        Ride Cymbal
      </button>
    </div>

    <div id="notes">
    </div>
</div>
  <script type="text/javascript">

var offset = 0
function currentBeat() {
  if (offset == 0) { return 0; }
  var duration = Tone.now() - offset;
  var bpm = Tone.Transport.bpm.value
  var secondsPerBeat = 1.0 / bpm * 60.0
  var beats = Math.floor(duration / secondsPerBeat)
  // console.log(duration, bpm, secondsPerBeat, beats);
  return beats;
}

Tone.Transport.bpm.value = 90;
Tone.Transport.loop = true;
Tone.Transport.loopStart = "0";
Tone.Transport.loopEnd = "2m";

var loop = new Tone.Loop(updatePattern, "32n");

var activeInstrument = 'B';
var outerCustomPattern = emptyPattern();
var innerCustomPattern = emptyPattern();
var keys = createSequence();

var samplerCustomPattern = emptyPattern();
var sampler = createSampler();

var sequence = [];
var currentSequence = -1;

function emptyPattern() {
  return {
    value: Array(32).fill('-'), 
    amplitude: Array(32).fill(0)
  }
}

function emptyPreset() {
  return {innerCustomPattern: emptyPattern(),
          outerCustomPattern: emptyPattern(),
          samplerCustomPattern: emptyPattern()}
}


function updatePattern(time) {
  var progressStep = Math.floor(Tone.Transport.progress * 64) % 32

  drawPattern(innerPattern, innerCustomPattern, innerMidRadius, progressStep)
  drawPattern(outerPattern, outerCustomPattern, outerMidRadius, progressStep)
  drawPattern(samplerPattern, samplerCustomPattern, samplerMidRadius, progressStep)
  updateNumbers(progressStep);
  updateHand(progressStep);

  if (rhythmPolygon.checked) {
    drawPolygons();
  }

  updatePosition(positionGroup, currentBeat());
  layer.batchDraw();
}

loop.start();

function createSequence() {
  var keys = new Tone.Players({
			"B" : "Sounds/Rhythm/Kit_1/Samples/bass.wav",
			"S" : "Sounds/Rhythm/Kit_1/Samples/snare.wav",
      "H" : "Sounds/Rhythm/Kit_1/Samples/hihat.wav",
      "O" : "Sounds/Rhythm/Kit_1/Samples/hihat_open.wav",
      "R" : "Sounds/Rhythm/Kit_1/Samples/rimshot.wav",
      "C" : "Sounds/Rhythm/Kit_1/Samples/ride.wav"
    }).toMaster();
    return keys; 
}

var scale = ['B3', 'D4', 'E4', 'F#4', 'A4', 'B4', 'D5'];
// https://mycolor.space/?hex=%23845EC2&sub=1
var gradient = ['#0089BA','#2C73D2','#845EC2','#D65DB1','#FF6F91','#FF9671','#FFC75F'];

function createSampler() {
  var notes = ['A3', 'B3', 'C#4', 'D3', 'D4', 'E3', 'E4', 'F#3', 'F#4', 'G3'];
  var baseDir = "Sounds/ElectroSynths/";
  var baseVoice = "NKnee ";
  var extension = ".wav";
  var config = {}
  notes.forEach(function(note){
    config[note] = baseDir + baseVoice + encodeURIComponent(note) + extension;
  })
  console.log(config);
  var sampler = new Tone.Sampler(config).toMaster();
  return sampler;
}

var allSteps = new Array(32);
for (var i = 0; i < allSteps.length; i++) {
  allSteps[i] = i;
}

var bassSnare = document.getElementById('bassSnareCheck');
var hiHat = document.getElementById('hiHatCheck');
var melody = document.getElementById('melodyCheck');

var loop = new Tone.Sequence(function(time, step){
  if (hiHat.checked) {
    playActiveNote(innerCustomPattern, step, time);
  }
  if (bassSnare.checked) {
    playActiveNote(outerCustomPattern, step, time);
  }
  if (melody.checked) {
    playActiveNote(samplerCustomPattern, step, time);
  }
  if (currentSequence >= 0 && step == 31) {
    currentSequence = ++currentSequence % sequence.length
    updateSequenceDisplay();
    loadPreset(presets[sequence[currentSequence]]);
  }
}, allSteps, "32n").start(0);

function playActiveNote(customPattern, step, time) {
  var note = customPattern.value[step];
  if (note == '-') { return; }
  if (note.toUpperCase() == 'H') {
    keys.get('O').stop();
  }
  if (isRhythm(note)) {
    keys.get(note).volume.value = amplitudeFor(customPattern, step);
    keys.get(note).start(time);
  } else {
    var velocity = velocityFor(customPattern, step);
    sampler.triggerAttack(note, time, velocity);
  }
}

function isRhythm(note) {
  return note.length == 1
}

function amplitudeFor(pattern, step) {
  var note = pattern.value[step];
  var amplitude = pattern.amplitude[step] || 0;

  var max = note == 'H' ? 8 : 0;
  var mid = note == 'H' ? 2 : -2;
  var min = -4

  switch (amplitude) {
    case 0:
    default:
      return -99;
      break;
    case 1:
      return -4;
      break;
    case 2:
      return 'H' ? 2 : -2;
      break;
    case 3:
      return 'H' ? 8 : 0;
      break;
  }
}

function velocityFor(pattern, step) {
  var amplitude = pattern.amplitude[step] || 0;

  switch (amplitude) {
    case 0:
    default:
      return 0;
      break;
    case 1:
      return 0.25;
      break;
    case 2:
      return 0.5;
      break;
    case 3:
      return 1.0;
      break;
  }
}

var buffersLoaded = false

Tone.Buffer.on('load', function(){
  buffersLoaded = true
  updateLoading()
})

  // first we need to create a stage
var stage = new Konva.Stage({
  container: 'container',   // id of container <div>
  width: 1028,
  height: 768 - 200
});

var layer = new Konva.Layer();

var loadingText = new Konva.Text({
        x: stage.width() / 2 - 150,
        y: stage.height() / 2 - 100,
        text: 'Loading...',
        fontSize: 30,
        fill: 'black',
        width: 300,
        height: 100,
        verticalAlign: 'middle',
        align: 'center'
      });
layer.add(loadingText)

function updateLoading() {
  var isLoaded = buffersLoaded
  loadingText.visible(!isLoaded)
  if (isLoaded) {
    // selectButton(bdsdCircles, bdsdData, '#F9BAF9', '#C687C6')
    // drawPattern(innerPattern, bdDisplayPattern[bdsdData.selected], innerMidRadius, 0)
    // selectButton(hhCircles, hhData, '#9ECCEF', '#6B99BC')
    // drawPattern(outerPattern, hhDisplayPattern[hhData.selected], outerMidRadius, 0)
  }
  layer.batchDraw();
}

var patternWidth = 34 + 12
var innerRadius = 97 + 12
var patternOriginX = stage.width() / 2
var patternOriginY = innerRadius + patternWidth * 4
var innerMidRadius = innerRadius + patternWidth / 2
var outerMidRadius = innerRadius + patternWidth * 1.5
var samplerMidRadius = innerRadius + patternWidth * 2.5
var outerRadius = samplerMidRadius + patternWidth / 2



// https://jsfiddle.net/PimpTrizkit/a7ac0qvp/
var noteColors = {
    "_" : "#D9D9D9",
    "B" : "#C687C6",
    "S" : "#6B63AA",
    "R" : "#D88766",
    "X" : "#6B99BC",
    "H" : "#6B99BC",
    "O" : "#355670",
    "C" : "#41C398",
  }

for (var i = 0; i < scale.length; i++) {
  noteColors[scale[i]] = gradient[i];
}

noteColors.getColor = function(note, amplitude=3) {
  var p = (3 - amplitude) * 0.1;
  return pSBC(p, this[note]);
}

function createSlices() {
  var sliceGroup = new Konva.Group()
  for (var i = 0; i < 16; i++) {
    var point = pointBeginning(i, outerRadius, patternOriginX, patternOriginY, 16);
    var strokeWidth = 2
    var strokeColor = '#e9e9e9'
    if (i % 8 == 0) {
      strokeWidth = 6
      strokeColor = '#cccccc'
    }
    if ((i-4) % 8 == 0) {
      strokeWidth = 4
      strokeColor = '#cccccc'
    }
    var line = new Konva.Line({
      points: [patternOriginX, patternOriginY, point.x, point.y],
      stroke: strokeColor,
      strokeWidth: strokeWidth,
      opacity: 0.5,
      listening: false
    });
    console.log(patternOriginX, patternOriginY, point.X, point.Y);
    sliceGroup.add(line);
  }
  return sliceGroup;
}

 
var controlBackgrounds = ['#F5F1F0', '#D9D9D9', '#B5B5B5'];
var innerFilter = ['H','O', 'C'];
var innerPattern = new Konva.Group()
var innerPatternControl = createPatternControl(patternOriginX, patternOriginY, innerRadius, innerRadius + patternWidth, controlBackgrounds[0], innerPattern, innerCustomPattern, innerFilter, true, false, function(){ toggleSequence();}, function(){  toggleSequence(); })
var outerPattern = new Konva.Group()
var outerFilter = ['B','S','R'];
var outerPatternControl = createPatternControl(patternOriginX, patternOriginY, innerRadius + patternWidth, innerRadius + patternWidth * 2, controlBackgrounds[1], outerPattern, outerCustomPattern, outerFilter, false, false, function(){ toggleSequence();}, function(){  toggleSequence(); })
var samplerFilter = scale;
var samplerPattern = new Konva.Group()
var samplerPatternControl = createPatternControl(patternOriginX, patternOriginY, innerRadius + patternWidth * 2, innerRadius + patternWidth * 3, controlBackgrounds[2], samplerPattern, samplerCustomPattern, samplerFilter, false, true, function(){ toggleSequence();}, function(){  toggleSequence(); })

layer.add(samplerPatternControl);
layer.add(outerPatternControl);
layer.add(innerPatternControl);

// drawEmptyPattern(innerPattern, innerMidRadius)
// drawEmptyPattern(outerPattern, outerMidRadius)
// drawEmptyPattern(samplerPattern, samplerMidRadius)
var numbers = createNumbers(samplerMidRadius + patternWidth);
layer.add(numbers);

var slices = createSlices();
layer.add(slices);

var hand = createHand(patternOriginX, patternOriginY, innerRadius + patternWidth * 3)
layer.add(hand);

var mirrorVerticalLine = createVerticalLine();
layer.add(mirrorVerticalLine);
var mirrorHorizontalLine = createHorizontalLine();
layer.add(mirrorHorizontalLine);

function createVerticalLine() {
    var startPoint = pointBeginning(0, outerRadius, patternOriginX, patternOriginY, 16);
    var endPoint = pointBeginning(8, outerRadius, patternOriginX, patternOriginY, 16);
    var line = new Konva.Line({
      points: [startPoint.x, startPoint.y, endPoint.x, endPoint.y],
      stroke: '#add8e6',
      strokeWidth: 4,
      opacity: 0.75,
      listening: false,
      visible: false
    });
    return line;
}

function createHorizontalLine() {
    var startPoint = pointBeginning(4, outerRadius, patternOriginX, patternOriginY, 16);
    var endPoint = pointBeginning(12, outerRadius, patternOriginX, patternOriginY, 16);
    var line = new Konva.Line({
      points: [startPoint.x, startPoint.y, endPoint.x, endPoint.y],
      stroke: '#add8e6',
      strokeWidth: 4,
      opacity: 0.75,
      listening: false,
      visible: false
    });
    return line;
}

var positionGroup = createPositionGroup(stage.width() - 200,98, 0);
layer.add(positionGroup);

function createPositionGroup(x, y, beat) {
  var positionGroup = new Konva.Group();
  
  var size = 128 / 2
  var width = 16 / 2

  var text = new Konva.Text({
        x: x - size/2,
        y: y - size/2,
        text: beat.toString(),
        fontSize: 24,
        fill: '#DB3352',
        width: size,
        height: size,
        align: 'center',
        verticalAlign: 'middle'
      });
  positionGroup.add(text);

  var progress = (beat + 1) / 4
  var angle = progress * 360 - 90
  var radius = size / 2 
  var arc = new Konva.Arc({
        x: x,
        y: y,
        innerRadius: radius - width / 2,
        outerRadius: radius + width / 2,
        angle: angle,
        fill: '#AAAAAA',
        stroke: '#AAAAAA',
        strokeWidth: 1,
        rotation: -90,
        listening: false,
        visible: false
      });
  positionGroup.add(arc)

  return positionGroup;
}

function updatePosition(group, beat) {
  
  var bar = Math.floor(beat / 4)
  
  var progress = (beat % 4 + 1) / 4
  var angle = progress * 360

  var arc = group.getChildren(function(node){
   return node.getClassName() === 'Arc';
  });

  arc[0].visible(offset > 0);
  arc[0].angle(angle);

  var text = group.getChildren(function(node){
   return node.getClassName() === 'Text';
  }); 

  text[0].text(bar.toString())

}

function createPatternControl(originX, originY, innerRadius, outerRadius, fill, patternGroup, customPattern, filter, enableInteriorClick = false, enableExteriorClick = false, directClick, interiorClick) {
  var patternControl = new Konva.Group();

  var patternRing = createPatternRing(originX, originY, innerRadius, outerRadius, fill);
  patternRing.hitFunc(function(context) {
      context.beginPath();
      var innerArcRadius = enableInteriorClick ? 0 : innerRadius;
      var outerArcRadius = enableExteriorClick ? outerRadius + patternWidth : outerRadius;
      context.arc(0, 0, innerArcRadius, 0, Math.PI * 2, true);
      context.arc(0, 0, outerArcRadius, 0, Math.PI * 2, true);
      context.fillStrokeShape(this);
    })
  function patternRingEvent(event) {
    var point = this.getStage().getPointerPosition();
    var distance = Math.pow((point.x - this.x()),2) + Math.pow((point.y - this.y()),2)
    var interior = distance <= Math.pow(innerRadius, 2)
    var exterior = distance >= Math.pow(outerRadius, 2)
    if (interior) {
      interiorClick()
    } else {
      directClick()
    }
  }
  patternRing.on('click', patternRingEvent);
  patternRing.on('tap', patternRingEvent);
      
  patternControl.add(patternRing);

  // [0,4,8,12].forEach(function(step) { 
  //   var pulse = createPulse(originX, originY, innerRadius, outerRadius, step); 
  //   patternControl.add(pulse);
  // })

  var highlightRing = createPatternRing(originX, originY, innerRadius, outerRadius, '#F0E6C3');
  highlightRing.visible(false);
  highlightRing.name('highlightRing');
  highlightRing.listening(false);
  patternControl.add(highlightRing);

  patternControl.add(patternGroup)

  for (var i = 0; i < 32; i++) {
    var step = createStepSegments(originX, originY, innerRadius, outerRadius, patternGroup, i, customPattern, filter);
    patternControl.add(step);
  }

  return patternControl
}

var dragStart = {x: 0, y:0}
var dragDegree = 0;

function createStepSegments(originX, originY, innerRadius, outerRadius, patternGroup, step, pattern, filter) {
  var segmentDegree = 360/32
  var rotation = -90 + step * segmentDegree;
  var arc = new Konva.Arc({
        x: originX,
        y: originY,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        angle: segmentDegree,
        stroke: noteColors[activeInstrument],
        strokeWidth: 0,
        rotation: rotation,
        // visible: false,
        draggable: true,
        dragBoundFunc: function() {
          var pos = this.getAbsolutePosition();
          return {x: pos.x, y: pos.y};
        }
      });
  arc.on('mouseover', function() {
    if (filter.indexOf(activeInstrument.toUpperCase()) == -1 ) { return; }
    arc.strokeWidth(1);
    arc.stroke(noteColors[activeInstrument]);
    layer.batchDraw();
  });
  arc.on('mouseout', function() {
    if (filter.indexOf(activeInstrument.toUpperCase()) == -1) { return; }
    arc.strokeWidth(0);
    layer.batchDraw();
  });
  function arcEvent(){
    if (filter.indexOf(activeInstrument.toUpperCase()) == -1) { return; }
    if (activeInstrument.length > 1) {
      var pointer = stage.getPointerPosition();
      var drag = distance(originX, originY, pointer.x, pointer.y);
      var travel = drag - innerRadius;
      var stepSize = patternWidth / scale.length;
      var index = Math.round(travel / stepSize);
      toggleStep(step, pattern, scale[index]);
    } else {
      toggleStep(step, pattern);
    }
    
    drawPattern(patternGroup, pattern, innerRadius + patternWidth / 2)
  }
  arc.on('click tap', arcEvent);
  arc.on('dragstart', function(){
    var note = pattern.value[step]
    if (note.length <= 1) { return }
    dragStart = stage.getPointerPosition();
    dragDegree = scale.indexOf(note);
  });
  arc.on ('dragmove', function(){
    var note = pattern.value[step]
    if (note.length <= 1) { return }
    var pointer = stage.getPointerPosition();
    var origin = distance(originX, originY, dragStart.x, dragStart.y);
    var drag = distance(originX, originY, pointer.x, pointer.y);
    var travel = drag - origin;

    var factor = patternWidth * 2 / scale.length
    var min = factor * -dragDegree;
    var max = factor * (scale.length - 1 - dragDegree);
    var normalized = Math.max(Math.min(max, travel),min);
    var newIndex = dragDegree + Math.round(normalized / factor);

    pattern.value[step] = scale[newIndex];
    updatePattern();
  });
  return arc
}

function distance(x1, y1, x2, y2) {
  return  Math.sqrt(Math.pow((x2 - x1),2) + Math.pow((y2 - y1),2));
}

var mirrorHorizontal = document.getElementById('mirrorHorizontal');
mirrorHorizontal.addEventListener('click',
  function(event){
    mirrorHorizontalLine.visible(this.checked);
    layer.batchDraw();
  }, false)
var mirrorVertical = document.getElementById('mirrorVertical');
mirrorVertical.addEventListener('click',
  function(event){
    mirrorVerticalLine.visible(this.checked);
    layer.batchDraw();
  }, false)

var resetButton = document.getElementById('reset');
resetButton.addEventListener('click',
  function(event){
    loadPreset(emptyPreset());
    updatePattern();
  }, false)

function toggleStep(index, pattern, instrument=activeInstrument) {
  var currentStep = pattern.value[index];

  var currentAmplitude = pattern.amplitude[index] || 0;
  var amplitudeMax = 3;

  var amplitude, value;
  switch (currentStep) {
    case instrument:
      amplitude = ++currentAmplitude % 4;
      value = amplitude == 0 ? '-' : instrument;
      break;
    case '-':
    default:
      amplitude = 1;
      value = instrument;
      break;
  }

  console.log(amplitude);
  pattern.amplitude[index] = amplitude;
  pattern.value[index] = value;


  if (mirrorVertical.checked) {
    var verticalIndex = reflectPatternVertical(index, value, amplitude, pattern);
    if (mirrorHorizontal.checked) {
      reflectPatternHorizontal(verticalIndex, value, amplitude, pattern);
    }
  }

  if (mirrorHorizontal.checked) {
    horizontalIndex = reflectPatternHorizontal(index, value, amplitude, pattern);
  }

  updatePattern();
}

function reflectPatternHorizontal(index, value, amplitude, pattern) {
  var offset = index % 2 == 0 ? 30 : 31;
  var newIndex = (offset + 16 - index) % 32;
  pattern.amplitude[newIndex] = amplitude;
  pattern.value[newIndex] = value;
  return newIndex;
}

function reflectPatternVertical(index, value, amplitude, pattern) {
  var offset = index % 2 == 0 ? 30 : 31;
  var newIndex = (offset - index) % 32;
  pattern.amplitude[newIndex] = amplitude;
  pattern.value[newIndex] = value;
  return newIndex;
}

function wrapMod(x, n) {
  return (x % n + n) % n
}

function createPatternRing(originX, originY, innerRadius, outerRadius, fill) {
  var ring = new Konva.Ring({
        x: originX,
        y: originY,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        fill: fill
      });

  return ring;
}

function createPulse(originX, originY, innerRadius, outerRadius, step) {
  var segmentDegree = 360/16
  var rotation = -90 + step * segmentDegree;
  var arc = new Konva.Arc({
        x: originX,
        y: originY,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        angle: segmentDegree,
        fill: '#FFF2C6',
        stroke: '#FFF2C6',
        strokeWidth: 1,
        rotation: rotation,
        listening: false
      });
    if (step == 0) {
      arc.stroke('#636363');
      arc.strokeWidth(1);
    }

    return arc
}

function createNumbers(radius) {
  var numbers = new Konva.Group();
  var number0 = drawNumber(radius - patternWidth/4, 0, 0)
  numbers.add(number0);
  var number16 = drawNumber(radius + patternWidth/4, 16, 16)
  numbers.add(number16);
  for (var i = 1; i < 16; i++) {
    var number = drawNumber(radius, i, i)
    numbers.add(number)
  }
  return numbers;
}

function drawNumber(radius, number, step) {
  var segment = Math.PI * 2 / 16 
  var dAlpha = - Math.PI / 2 + step * segment;
  var dx = Math.cos(dAlpha) * radius;
  var dy = Math.sin(dAlpha) * radius;
    
  var label = new Konva.Text({
    x: patternOriginX + dx,
    y: patternOriginY + dy,
    text: number.toString(),
    fontSize: 12,
    fill: '#636363',
    width: 20,
    height: 20,
    align: "center",
    verticalAlign: "middle",
    offsetX: 10,
    offsetY: 10,
    visible: number % 4 == 0
  });
  return label
}

function updateNumbers(step) {
  var normalizedStep = Math.floor(step/2);
  var numberLabels = numbers.getChildren(function(node){
   return node.getClassName() === 'Text';
  });
  numberLabels.forEach( function(label) {
    var number = Number(label.text());
    if (number % 4 == 0) { 
      label.visible(true);
    } else { 
      label.visible(number <= normalizedStep);
    }
  })
}

function createHand(originX, originY, radius) {
  var segmentDegree = 360/16;
  var hand = new Konva.Arc({
        x: originX,
        y: originY,
        innerRadius: 0,
        outerRadius: radius,
        angle: segmentDegree,
        fill: '#FFF2C6', 
        rotation: -90,
        opacity: 0.5,
        listening: false
      });
  return hand
}

function updateHand(step) {
  var normalizedStep = Math.floor(step/2);
  var segmentDegree = 360/16
  var rotation = -90 + normalizedStep * segmentDegree;
  hand.rotation(rotation);
}

function loopFunction(i, buttonGroup, data, players, loopUrls, fillColor, activeColor, targetGroup, targetPatterns, targetRadius) {
  return function() {
    data.selected = i;
    selectLoop(i, players, loopUrls);
    selectButton(buttonGroup, data, fillColor, activeColor);
    drawPattern(targetGroup, targetPatterns[i], targetRadius);
  };
}

function selectButton(buttonGroup, data, fillColor, activeColor) {
  var nodes = buttonGroup.find('Circle')
  nodes.forEach(node => {
    node.fill(node.id() == data.selected ? activeColor : fillColor);
  })
  nodes = buttonGroup.find('Text')
  nodes.forEach(node => {
    node.fill(node.id() == data.selected ? 'white' : 'grey');
  })
  layer.batchDraw();
}

function selectLoop(index, players, loopUrls) {
  if (!playing(players, loopUrls)) { return; }

  for(var playerName in loopUrls) {
    var player = players.get(playerName)
    player.mute = playerName != index
  }
}

function playing(players, loopUrls) {
  for(var playerName in loopUrls) {
    var player = players.get(playerName)
    if (!player.mute) {
      return true;
    }
  }
  return false;
}

function toggleLoop(index, players, loopUrls) {
  Tone.context.resume()

  for(var playerName in loopUrls) {
    var player = players.get(playerName)
    if (playerName == index) {
      if (player.mute) {
        player.mute = false
        if (Tone.Transport.state != "started") {
          offset = Tone.now()
          Tone.Transport.start(offset)
        }
      } else {
        player.mute = true
      }
    } else {
      player.mute = true
    }
  }

  autoStopTransport();
  updatePattern();
}

function toggleSequence() {
  Tone.context.resume()
  if (Tone.Transport.state != "started") {
    offset = Tone.now()
    Tone.Transport.start(offset)
  } else {
    offset = 0;
    Tone.Transport.stop();
  }
  updatePattern()
}

function firstPlayer(players, loopUrls) {
    for(var playerName in loopUrls) {
      var player = players.get(playerName)
      if (player.mute) {
        return index
      }
    }
    return -1
}

function drawEmptyPattern(targetGroup, radius) {
  for (var i = 0; i < 16; i++) {
    var tick = createTick(patternOriginX, patternOriginY, radius, i)
    targetGroup.add(tick)
  }
}

function drawPattern(targetGroup, pattern, radius, step = 0) {
  targetGroup.removeChildren()

  for (var i = 0; i < pattern.value.length; i++) {

    // if (i == step  && i % 2 == 0) {
    //   var normalizedStep = i / 2
    //   var activeSegment = createActiveSegment(patternOriginX, patternOriginY, radius - patternWidth / 2, radius + patternWidth / 2, normalizedStep);
    //   targetGroup.add(activeSegment);
    // }

    var note = pattern.value[i];
    var amplitude = pattern.amplitude[i] || 0;
    if (note == '-' && i % 2 == 0) {
      // var normalizedStep = i / 2
      // var tick = createTick(patternOriginX, patternOriginY, radius, normalizedStep)
      // targetGroup.add(tick)
    } else if (noteColors.hasOwnProperty(note)) {
      var noteColor = noteColors.getColor(note, amplitude);
      if (note.length > 1) {
        var noteNode = createHarmonicNote(i, noteColor, note, patternOriginX, patternOriginY, radius)
      } else {
        var noteNode = createNote(i, noteColor, patternOriginX, patternOriginY, radius)
      }
      targetGroup.add(noteNode)
    }
  }

  // draw active step

  // do I need to draw the active step before the other pattern? 
  // do I need to skip the active step when drawing the other notes
  // consider 32nd notes

  layer.batchDraw();
}

function createActiveSegment(originX, originY, innerRadius, outerRadius, step) {
  var segmentDegree = 360/16
  var rotation = -90 + step * segmentDegree - segmentDegree/2
  var fillColor = step % 2 == 0 ? '#FFF2C6' : '#E3FF8F';
  var arc = new Konva.Arc({
        x: originX,
        y: originY,
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        angle: segmentDegree,
        fill: fillColor,
        rotation: rotation
      });
  if (step == 0) {
    arc.stroke('#636363');
    arc.strokeWidth(1);
  }
  return arc
}

function createTick(originX, originY, radius, step) {
  var stroke = "#636363";
  var segmentDegree = 360/16
  var rotation = -90 + step * segmentDegree
  var tick = new Konva.Circle({
        x: originX,
        y: originY,
        radius: 3,
        stroke: stroke,
        strokeWidth: 1,
        rotation: rotation
      });
  tick.offsetX(-radius)
  return tick
}

function createNote(step, color, originX, originY, radius) {
  var segmentDegree = 360/32;
  var rotation = -90 + step * segmentDegree;
  var angle = step % 2 == 0 ? 360/16 : 360/32;
  var note = new Konva.Arc({
    x: originX,
    y: originY,
    innerRadius: radius - patternWidth/2,
    outerRadius: radius + patternWidth/2,
    angle: angle,
    fill: color,
    stroke: 'rgba(255,255,255,0.5)',
    strokeWidth: 3,
    rotation: rotation,
    listening: false
  });
  
  return note
}

function createHarmonicNote(step, color, label, originX, originY, radius) {
  var group = new Konva.Group()

  var scaleDegree = scale.indexOf(label);
  var percent = (scaleDegree + 1) / scale.length;
  var innerRadius = radius - patternWidth/2;
  var outerRadius = innerRadius + patternWidth * percent;

  var segmentDegree = 360/32;
  var rotation = -90 + step * segmentDegree;
  var angle = step % 2 == 0 ? 360/16 : 360/32;
  var note = new Konva.Arc({
    x: originX,
    y: originY,
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    angle: angle,
    fill: color,
    stroke: 'rgba(255,255,255,0.5)',
    strokeWidth: 1,
    rotation: rotation,
    listening: false
  });

  var segment = Math.PI * 2 / 32 
  var offset = step % 2 == 0 ? segment : segment / 2;
  var dAlpha = - Math.PI / 2 + step * segment + offset;
  var dx = Math.cos(dAlpha) * radius;
  var dy = Math.sin(dAlpha) * radius;

  var size = 32;

  // var square = new Konva.Rect({
  //   x: patternOriginX + dx,
  //   y: patternOriginY + dy,
  //   width: size,
  //   height: size,
  //   fill: color,
  //   offsetX: size / 2,
  //   offsetY: size / 2
  // });
    
  var noteLabel = new Konva.Text({
    x: patternOriginX + dx,
    y: patternOriginY + dy,
    text: label,
    fontSize: 14,
    fontStyle: 'bold',
    fill: 'white',
    width: size,
    height: size,
    align: "center",
    verticalAlign: "middle",
    offsetX: size / 2,
    offsetY: size / 2
  });

  group.add(note);
  group.add(noteLabel);
  
  return group
}

function autoStopTransport() {
  if (!someLoop()) {
    Tone.Transport.stop();
    offset = 0;
  }
}

function someLoop() {
  console.log("bdsd:", someBDSDLoop(), "hh:",someHHLoop());
  return someBDSDLoop() || someHHLoop();
}

function someBDSDLoop() {
  for(var playerName in bdsdURLs) {
    var player = bdsdPlayers.get(playerName)
    if (!player.mute) {
      return true
    }
  }
  return false;
}

function someHHLoop() {
  for(var playerName in hhURLs) {
    var player = hhPlayers.get(playerName)
    if (!player.mute) {
      return true
    }
  }
  return false;
}

stage.add(layer);

var slider = document.getElementById("tempo");
var output = document.getElementById("tempoLabel");
output.innerHTML = "Tempo: " + slider.value;
      
slider.oninput = function() {
  output.innerHTML = "Tempo: " + this.value;
  Tone.Transport.bpm.value = this.value;
}

var notes = document.getElementById("notes");
scale.slice().reverse().forEach(function(note, index){
  var button = document.createElement("BUTTON");
  button.innerHTML = note;
  button.className = "note"
  button.style.backgroundColor = noteColors.getColor(note);
  button.onmousedown = function() {
    // console.log(note);
    // sampler.triggerAttack(note);
    activeInstrument = note;
    showSelectedButton();
    selectRing();
  }
  notes.appendChild(button);
})

var rhythmButtons = document.getElementsByClassName("rhythm");
Array.prototype.forEach.call(rhythmButtons, function(button){
  var instrument = button.dataset.instrument;
  button.addEventListener('click', 
    function() { 
      activeInstrument = instrument;
      showSelectedButton();
      selectRing();
    }, 
    false
  );
})

function showSelectedButton() {
  var rhythmButtons = document.getElementsByClassName("rhythm");
  Array.prototype.forEach.call(rhythmButtons, function(button){
    var instrument = button.dataset.instrument;
    button.style.backgroundColor = activeInstrument.toUpperCase() == instrument.toUpperCase() ? noteColors[activeInstrument] : noteColors["_"];
  })
}

showSelectedButton();
selectRing();

function selectRing() {
  var controls = [innerPatternControl, outerPatternControl, samplerPatternControl];
  var filters = [innerFilter, outerFilter, samplerFilter];
  for (var i=0; i<controls.length; i++) {
    var control = controls[i];
    var filter = filters[i];
    var ring = control.findOne('.highlightRing');
    if (filter.includes(activeInstrument)) {
      ring.visible(true);
    } else {
      ring.visible(false);
    }
  }
  layer.batchDraw();
}

var bass90Button = document.getElementById("bass90");
bass90Button.addEventListener('click', 
  function() {
    rotateAnimation(outerCustomPattern, outerMidRadius - patternWidth / 2,
    function() {
      patternRotate(outerCustomPattern, 8)
      updatePattern();
    });
  }, 
  false
);

var hihat90Button = document.getElementById("hihat90");
hihat90Button.addEventListener('click', 
  function() {
    rotateAnimation(innerCustomPattern, innerMidRadius - patternWidth / 2,
    function() {
      patternRotate(innerCustomPattern, 8);
      updatePattern();
    });
  }, 
  false
);

var melody90Button = document.getElementById("melody90");
melody90Button.addEventListener('click', 
  function() {

    rotateAnimation(samplerCustomPattern, samplerMidRadius - patternWidth / 2,
    function() {
      patternRotate(samplerCustomPattern, 8);
      updatePattern();
    });
  }, 
  false
);

function patternRotate(pattern, count) {
  arrayRotate(pattern.value, count);
  arrayRotate(pattern.amplitude, count);
}

function arrayRotate(arr, count) {
  arr.unshift.apply(arr, arr.splice(arr.length-count, count));
  return arr;
}

function rotateAnimation(pattern, radius, completion) {
  var slices = patternSliceGroup(pattern, radius);
  layer.add(slices);
  layer.batchDraw();

  var duration = 333;
  var rotation = 90;
  var anim = new Konva.Animation(function(frame) {
    var time = frame.time,
      timeDiff = frame.timeDiff,
      frameRate = frame.frameRate;
    if (time >= duration) {
      slices.destroy();
      anim.stop();
      completion();
    }
    var angle = rotation * frame.time / duration;
    slices.rotation(angle);
  }, layer);
  anim.start();
}

function patternSliceGroup(pattern, radius) {
  var sliceGroup = new Konva.Group({
    x: patternOriginX,
    y: patternOriginY
  });

  var originX = patternOriginX, originY = patternOriginY;
  for (var i = 0; i < 32; i++) {
    if (pattern.value[i] == '-' || pattern.amplitude[i] == 0) {
      continue;
    }
    var point = pointBeginning(i, radius, 0, 0);
    var strokeWidth = 8;
    var strokeColor = 'black';
    var line = new Konva.Line({
      points: [0, 0, point.x, point.y],
      stroke: strokeColor,
      strokeWidth: strokeWidth,
      opacity: 0.5,
      listening: false
    });
    sliceGroup.add(line);
  }
  return sliceGroup;  
}

var presetCounter = 1;
var presets = [];
var savePresetButton = document.getElementById("savePresetButton");
var presetList = document.getElementById("presetList");

savePresetButton.addEventListener('click', 
  function() {
    var entry = document.createElement('li');
    var link = document.createElement('a');
    link.href = ''
    link.innerHTML = "Preset " + presetCounter;
    link.dataset.presetID = presetCounter
    entry.appendChild(link);
    var id = 'preset' + presetCounter;
    entry.setAttribute('id',id);
    presets[presetCounter] = capturePreset();
    link.addEventListener('click',
      function(event){
        var presetToLoad = presets[this.dataset.presetID];
        loadPreset(presetToLoad);
        updatePattern();
        event.preventDefault();
      }, false)
    entry.appendChild(deleteButton(presetCounter));
    entry.appendChild(sequenceButton(presetCounter));
    presetList.appendChild(entry);
    presetCounter += 1;
    updatePattern();
  }, 
  false
);

function deleteButton(preset) {
  var deleteButton = document.createElement("BUTTON");
  deleteButton.innerHTML = "X";
  deleteButton.addEventListener('click',
    (function(index) {
      return function() {
        deletePreset(index, this.parentNode);
      }
    })(preset),
    false
  );
  return deleteButton;
}

function deletePreset(index, node) {
  node.parentNode.removeChild(node);
  delete presets[index];
  sequence = sequence.filter(function(i) {
      return i !== index;
  })
  currentSequence = -1;
  updateSequenceDisplay();
}

var sequenceDisplay = document.getElementById('sequenceDisplay');
function sequenceButton(preset) {
  var sequenceButton = document.createElement("BUTTON");
  sequenceButton.innerHTML = ">";
  sequenceButton.addEventListener('click',
    (function(index) {
      return function() {
        sequence.push(preset);
        updateSequenceDisplay();
      }
    })(preset),
    false
  );
  return sequenceButton;
}

function updateSequenceDisplay() {
  var display = sequence.map(function(preset, index){
    var step = document.createElement("SPAN")
    step.innerHTML = preset;
    step.className = index == currentSequence ? 'active' : '';
    return step.outerHTML;
  })
  sequenceDisplay.innerHTML = display.join(",");
}

var sequenceControl = document.getElementById("sequenceControl");
sequenceControl.addEventListener('click', 
  function() {
    if (currentSequence >= 0) {
      currentSequence = -1;
      this.innerHTML = "start";
    } else {
      currentSequence = 0;
      loadPreset(presets[sequence[currentSequence]]);
      updateSequenceDisplay();
      this.innerHTML = "stop";
    }
  }, 
  false
);

function capturePreset() {
  var preset = {
      innerCustomPattern: patternFrom(innerCustomPattern),
      outerCustomPattern: patternFrom(outerCustomPattern),
      samplerCustomPattern: patternFrom(samplerCustomPattern)
  }
  return preset;
}     

function loadPreset(preset) {
  loadPattern(preset.innerCustomPattern, innerCustomPattern);
  loadPattern(preset.outerCustomPattern, outerCustomPattern);
  loadPattern(preset.samplerCustomPattern, samplerCustomPattern);
}

function patternFrom(pattern) {
  var clone = {
    value: pattern.value.slice(),
    amplitude: pattern.amplitude.slice()
  }
  return clone
}

function loadPattern(pattern, target) {
  target.value = pattern.value.slice();
  target.amplitude = pattern.amplitude.slice();
}


var sequenceClear = document.getElementById("sequenceClear");
sequenceClear.addEventListener('click', 
  function() {
    currentSequence = -1;
    sequence = [];
    updateSequenceDisplay();
  }, 
  false
);



var rhythmPolygon = document.getElementById('rhythmPolygon');


rhythmPolygon.addEventListener('change', 
  function() {
    togglePolygon(rhythmPolygon.checked);
  }, 
  false
);

function togglePolygon(show) {
  if (show) {
      drawGuideSquare();
      drawPolygons()
    } else {
      guideSquare.destroy();
      destroyPolygons();
      polygons = Array(3).fill(new Konva.Shape())
      layer.batchDraw();
    }
}

var guideSquare = new Konva.Shape();

function drawGuideSquare() {
  var radius = innerRadius;
  var points = [];
  [0,8,16,24].forEach( function(i){
    var point = pointFor(i, radius, patternOriginX, patternOriginY);
    points.push(point.x, point.y);
  })

  guideSquare = new Konva.Line({
        points: points,
        fill: '#D9D9D9',
        strokeWidth: 0,
        closed: true,
        listening: false,
        opacity: 0.5
      });
  layer.add(guideSquare);
  layer.batchDraw();
}


var polygons = Array(3).fill(new Konva.Shape())

function drawPolygons() {
  destroyPolygons()

  polygons[0] = drawPolygon(innerCustomPattern, innerMidRadius - patternWidth / 2);
  polygons[1] = drawPolygon(outerCustomPattern, outerMidRadius - patternWidth / 2);  
  polygons[2] = drawPolygon(samplerCustomPattern, samplerMidRadius - patternWidth / 2);
  for (var i = 0; i < polygons.length; i++) {
    layer.add(polygons[i]);
  }
  
  layer.batchDraw();
}

function destroyPolygons() {
  for (var i = 0; i < polygons.length; i++) {
    polygons[i].destroy()
  }
}


function drawPolygon(pattern, radius) {
  var points = [];
  for (var i = 0; i < pattern.value.length; i++) {
    var note = pattern.value[i];
    if (note != '-') {
      var point = pointFor(i, radius, patternOriginX, patternOriginY);
      points.push(point.x, point.y);
    }
  }

  if (points.length == 0) {
    return new Konva.Shape();
  }

  polygon = new Konva.Line({
        points: points,
        stroke: 'black',
        strokeWidth: 1,
        closed: true,
        listening: false
      });
  return polygon;
}

function pointFor(step, radius, originX, originY, base=32) {
  var segment = Math.PI * 2 / base;
  var dAlpha = - Math.PI / 2 + step * segment;
  var dx = Math.cos(dAlpha) * radius;
  var dy = Math.sin(dAlpha) * radius;

  return {
    x: originX + dx,
    y: originY + dy
  }  
}

function pointBeginning(step, radius, originX, originY, base=32) {
  var segment = Math.PI * 2 / base;
  var dAlpha = - Math.PI / 2 + step * segment;
  var dx = Math.cos(dAlpha) * radius;
  var dy = Math.sin(dAlpha) * radius;

  return {
    x: originX + dx,
    y: originY + dy
  }  
}


</script>
</body>
</html>